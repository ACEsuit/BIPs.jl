

using BIPs, Statistics, StaticArrays, Random, Test, ACEcore, Printf,
      Polynomials4ML, LinearAlgebra, LuxCore, Lux, BenchmarkTools
using Polynomials4ML.Testing: print_tf  
using Lux, Optimisers, Zygote

rng = Random.GLOBAL_RNG

include("testing_tools.jl")
hyp_jets = sample_hyp_jets
jets = [ identity.(jet) for jet in hyp_jets ]
maxlen = maximum(length, jets)
X = jets[1]

##

order = 3
maxlevel = 6
n_pt = 4
n_tM = 2
n_th = 2
n_y = 2

f_bip_s = BIPs.LuxBIPs.simple_bips(; 
            order=order, maxlevel=maxlevel, 
            n_pt=n_pt, n_th=n_th, n_y=n_y, 
            maxlen = maxlen)

pss, sts = LuxCore.setup(rng, f_bip_s)
Bs = f_bip_s(X, pss, sts)[1]

##

# try to build a BIP model using Lux layers instead of 
# having a single layer that does all the work in-place 

bR, bT, bY = f_bip_s.l.bR, f_bip_s.l.bT, f_bip_s.l.bV

embed = BranchLayer((bR = bR, bT = bT, bY = bY))
pool = ACEcore.lux(f_bip_s.l.bA)
corr = ACEcore.lux(f_bip_s.l.bAA)

f_bip_l = Chain(; embed = embed, pool = pool, corr = corr, 
                  real = WrappedFunction(real) )

psl, stl = LuxCore.setup(rng, f_bip_l)
Bs_l = f_bip_l(X, psl, stl)[1]


Bs_l[2:end] â‰ˆ Bs[2:end]

##

# @info("Checking performance - pretty good:")
# @info("Manual:")
# @btime $f_bip_s($X, $pss, $sts)
# @info("Flux:")
# @btime $f_bip_l($X, $psl, $stl)

##

model_s = Chain(; bip = f_bip_s, 
                  l1 = Dense(length(f_bip_s), 5, tanh; init_weight=randn, use_bias=false), 
                  l2 = Dense(5, 1, tanh; init_weight=randn, use_bias=false),
                  out = WrappedFunction(x -> x[1]), )

model_l = Chain(; bip = f_bip_l,
                  l1 = Dense(length(f_bip_s), 5, tanh; init_weight=randn, use_bias=false), 
                  l2 = Dense(5, 1, tanh; init_weight=randn, use_bias=false),
                  out = WrappedFunction(x -> x[1]), )
        
pss, sts = LuxCore.setup(rng, model_s)
psl, stl = LuxCore.setup(rng, model_l)

model_s(X, pss, sts)[1]
model_l(X, psl, stl)[1]

gs = Zygote.gradient(ps -> model_s(X, ps, sts)[1], pss)[1]
gl = Zygote.gradient(ps -> model_l(X, ps, stl)[1], psl)[1]


##
# Finite difference test for model_s 

# model, ps, st = model_s, pss, sts
model, ps, st = model_l, psl, stl

ps_vec, re = destructure(ps)
us_vec = ( (randn(length(ps_vec)) ) # ./ (1:length(ps_vec))) 
           .* [ (rand() < 0.1) for _=1:length(ps_vec)] )

_ps(t) = re(ps_vec + t * us_vec)
_dot(nt1::NamedTuple, nt2::NamedTuple) = dot(destructure(nt1)[1], destructure(nt2)[1])

f0 = model(X, ps, st)[1] 
g0 = Zygote.gradient(ps -> model(X, ps, st)[1], ps)[1]
df0 = dot(destructure(g0)[1], us_vec)

for h in (0.1).^(1:12)
   fhp = model(X, _ps(h), st)[1]
   fhm = model(X, _ps(-h), st)[1]
   df_h = (fhp - f0) / h
   df_h2 = (fhp - fhm) / (2*h)
   @printf(" %.2e | %.2e  ,  %.2e \n", h, 
            abs(df_h - df0),
            abs(df_h2 - df0)
             )
end
